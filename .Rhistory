blog_gen()
blog_gen()
blog_gen()
blog_gen()
blog_gen()
blog_gen()
library(brocks)
functions(brocks)
?brocks
new_post(title = "Weekly Reading Recap")
library(brocks)
blog_gen()
library(brocks)
new_post("Bayesian networks for modeling policy impacts to support costs")
blog_gen()
library(brocks)
new_post("The Rise and Fall of American Growth")
view(data)
data()
install.packages("Rserve")
library(brocks)
?brocks
brocks()
?blog_gen
blog_gen()
library(brocks)
new_post("Understanding the Unemployment Rate")
library(brocks)
blog_gen()
library(brocks)
new_post("A Correlation Significance Curve")
blog_gen()
blog_gen()
blog_gen()
library(brocks)
blog_gen()
library(brocks)
new_post(title = "A Learning Curve R Package")
blog_gen()
new_post(title = "Creating a Central R Programming Resource for UC")
blog_gen()
new_post(title = "R Bootcamp")
blog_gen()
new_post(title = "Potential for an EVM package")
blog_gen()
blog_gen()
new_post(title = "Week 1 - UC-R.github.io")
blog_gen()
new_post(title = "16 learningCurve Functions")
unit_curve <- function(t, n, r, m = 1, na.rm = FALSE){
if(!is.numeric(t) | !is.numeric(m) | !is.numeric(n) | !is.numeric(r)){
stop('This function only works for numeric inputs!\n',
'You have provided objects of the following classes:\n',
't: ', class(t), '\n',
'm: ', class(m), '\n',
'n: ', class(n), '\n',
'r: ', class(r))
}
if(na.rm == TRUE) {
t <- t[!is.na(t)]
m <- m[!is.na(m)]
n <- n[!is.na(n)]
r <- r[!is.na(r)]
warning('Any strings with NA were filtered. This may result in \n',
'unexpected recycling.')
}
b <- log(r)/log(2)
y <- t * (n/m)^b
return(y)
}
blog_gen()
blog_gen()
blog_gen()
blog_gen()
blog_gen()
unit_cum_appx <- function(t, n, r, m = 1, na.rm = FALSE){
if(!is.numeric(t) | !is.numeric(m) | !is.numeric(n) | !is.numeric(r)){
stop('This function only works for numeric inputs!\n',
'You have provided objects of the following classes:\n',
't: ', class(t), '\n',
'm: ', class(n), '\n',
'n: ', class(n), '\n',
'r: ', class(r))
}
if( m > n ){
stop('This function approximates the cumulative hours/costs between \n',
'm and n; consequently, n must be larger than m.')
}
if(na.rm == TRUE) {
t <- t[!is.na(t)]
m <- m[!is.na(m)]
n <- n[!is.na(n)]
r <- r[!is.na(r)]
warning('Any strings with NA were filtered. This may result in \n',
'unexpected recycling.')
}
b <- log(r)/log(2)
c <- 1 + b
t1 <- t/(m^b)
y <- (t1 / c) * (((n + 0.5)^(c)) - ((m - 0.5)^(c)))
return(y)
}
unit_cum_exact <- function(t, n, r, m = 1, na.rm = FALSE){
if(!is.numeric(t) | !is.numeric(m) | !is.numeric(n) | !is.numeric(r)){
stop('This function only works for numeric inputs!\n',
'You have provided objects of the following classes:\n',
't: ', class(t), '\n',
'm: ', class(n), '\n',
'n: ', class(n), '\n',
'r: ', class(r))
}
if( m > n ){
stop('This function calculates the cumulative hours/costs between \n',
'm and n; consequenctly, n must be larger than m.')
}
if(na.rm == TRUE) {
t <- t[!is.na(t)]
m <- m[!is.na(m)]
n <- n[!is.na(n)]
r <- r[!is.na(r)]
warning('Any strings with NA were filtered. This may result in \n',
'unexpected recycling.')
}
b <- log(r)/log(2)
t1 <- t/(m^b)
i <- m:n
y <- t1 * i^b
return(sum(y))
}
system.time(unit_cum_exact(t = 100000000, n = 125, r = .85))
system.time(unit_cum_appx(t = 100000000, n = 125, r = .85))
unit_cum_exact(t = 100000000, n = 125, r = .85)
unit_cum_exact(t = 100, n = 100000000, r = .85)
system.time(unit_cum_exact(t = 100, n = 1000000, r = .85))
system.time(unit_cum_appx(t = 100, n = 1000000, r = .85))
blog_gen()
blog_gen()
blog_gen()
blog_gen()
ca_block <- function(t, n, r, m = 1, na.rm = FALSE){
if(!is.numeric(t) | !is.numeric(m) | !is.numeric(n) | !is.numeric(r)){
stop('This function only works for numeric inputs!\n',
'You have provided objects of the following classes:\n',
't: ', class(t), '\n',
'm: ', class(m), '\n',
'n: ', class(n), '\n',
'r: ', class(r))
}
if( m > n ){
stop('This function computes the total hours/costs for a production block for \n',
'units m through n; consequently, n must be larger than m.')
}
if(na.rm == TRUE) {
t <- t[!is.na(t)]
m <- m[!is.na(m)]
n <- n[!is.na(n)]
r <- r[!is.na(r)]
warning('Any strings with NA were filtered. This may result in \n',
'unexpected recycling.')
}
b <- log(r)/log(2)
c <- 1 + b
y <- t * (n^c - (m-1)^c)
return(y)
}
ca_block(t = 75, m = 200, n = 250, r = .9532)
ca_block(t = 75, m = 1, n = 250, r = .9532)
ca_block(t = 75, m = 200, n = 250, r = .9532)
delta <- function(t, m, n, r, level = "u") {
d <- unit_curve(t = t, m = m, n = m:n, r = r) - ca_unit(t = t, m = m, n = m:n, r = r)
if(level == "u") {
y <- d
}
if(level == "c") {
y <- cumsum(d)
}
if(level != "u" & level != "c"){
stop('Undefined specification for the level argument.' )
}
return(y)
}
delta(t = 50, m = 1, n = 100, r = .885)
ca_unit <- function(t, n, r, m = 1, na.rm = FALSE){
if(!is.numeric(t) | !is.numeric(m) |!is.numeric(n) | !is.numeric(r)){
stop('This function only works for numeric inputs!\n',
'You have provided objects of the following classes:\n',
't: ', class(t), '\n',
'n: ', class(n), '\n',
'n: ', class(n), '\n',
'r: ', class(r))
}
if(na.rm == TRUE) {
t <- t[!is.na(t)]
m <- m[!is.na(m)]
n <- n[!is.na(n)]
r <- r[!is.na(r)]
warning('Any strings with NA were filtered. This may result in \n',
'unexpected recycling.')
}
b <- log(r)/log(2)
c <- 1 + b
y <- t * ((n^c - (n-1)^c)) / (m^c - (m-1)^c)
return(y)
}
delta(t = 50, m = 1, n = 100, r = .885)
delta(t = 50, m = 1, n = 100, r = .885, level = c)
delta(t = 50, m = 1, n = 100, r = .885, level = "u")
delta(t = 50, m = 1, n = 100, r = .885, level = "c")
delta(t = 50, m = 1, n = 25, r = .885, level = "u")
delta(t = 50, m = 1, n = 25, r = .885, level = "c")
plot_delta(t = 50, m = 1, n = 25, r = .885, level = "u")
plot_delta <- function(t, m, n, r, level = "u"){
if(level != "u" & level != "c"){
stop('Undefined specification for the level argument.' )
}
if(level == "u") {
df <- data.frame(x = m:n, y = delta(t = t, m = m, n = n, r = r, level = "u"))
y <- ggplot(df, aes(x = x, y = y)) +
geom_line()
if(n < 100) y <- y + geom_point(size = .5)
}
if(level == "c") {
df <- data.frame(x = m:n, y = delta(t = t, m = m, n = n, r = r, level = "c"))
y <- ggplot(df, aes(x = x, y = y)) +
geom_line()
if(n < 100) y <- y + geom_point(size = .5)
}
return(y)
}
plot_delta(t = 50, m = 1, n = 25, r = .885, level = "u")
library(ggplot2)
plot_delta(t = 50, m = 1, n = 25, r = .885, level = "u")
plot_delta(t = 50, m = 1, n = 25, r = .885, level = "c")
plot_block_summary(t = 125, m = 201, n = 500, r = .75)
plot_block_summary <- function(t, m, n, r){
df <- data.frame(x = m:n, value = unit_curve(t = t, m = m, n = m:n, r = r))
midpoint <- data.frame(x = unit_block_summary(t, m, n, r)[[3]],
value = unit_block_summary(t, m, n, r)[[4]],
label = paste0("[", round(unit_block_summary(t, m, n, r)[[3]]), ", ", round(unit_block_summary(t, m, n, r)[[4]]), "]"))
ggplot(df, aes(x = x, y = value)) +
geom_line() +
geom_point(data = midpoint, aes(x = x, y = value)) +
geom_text(data = midpoint, aes(x = x, y = value, label = label),
hjust = 0, vjust = 0)
}
plot_block_summary(t = 125, m = 201, n = 500, r = .75)
}
unit_block_summary <- function(t, m, n, r, na.rm = FALSE){
if(!is.numeric(t) | !is.numeric(m) | !is.numeric(n) | !is.numeric(r)){
stop('This function only works for numeric inputs!\n',
'You have provided objects of the following classes:\n',
't: ', class(t), '\n',
'm: ', class(n), '\n',
'n: ', class(n), '\n',
'r: ', class(r))
}
if( m > n ){
stop('This function caculates summary statistics for the production block between \n',
'm and n; consequently, n must be larger than m.')
}
if(na.rm == TRUE) {
t <- t[!is.na(t)]
m <- m[!is.na(m)]
n <- n[!is.na(n)]
r <- r[!is.na(r)]
warning('Any strings with NA were filtered. This may result in \n',
'unexpected recycling.')
}
b <- log(r)/log(2)
c <- 1 + b
t1 <- t/(m^b)
k <- (((n + 0.5)^(c) - (m - 0.5)^(c)) / ((c) * (n - m + 1)))^(1/b)
t_k <- unit_curve(t = t1, n = k, r = r)
block_units <- n - m + 1
block_hours <- t_k * block_units
y <- list(`block units` = block_units,
`block hours` = block_hours,
`midpoint unit` = k,
`midpoint hours` = t_k)
return(y)
}
plot_block_summary <- function(t, m, n, r){
df <- data.frame(x = m:n, value = unit_curve(t = t, m = m, n = m:n, r = r))
midpoint <- data.frame(x = unit_block_summary(t, m, n, r)[[3]],
value = unit_block_summary(t, m, n, r)[[4]],
label = paste0("[", round(unit_block_summary(t, m, n, r)[[3]]), ", ", round(unit_block_summary(t, m, n, r)[[4]]), "]"))
ggplot(df, aes(x = x, y = value)) +
geom_line() +
geom_point(data = midpoint, aes(x = x, y = value)) +
geom_text(data = midpoint, aes(x = x, y = value, label = label),
hjust = 0, vjust = 0)
}
plot_block_summary(t = 125, m = 201, n = 500, r = .75)
plot_unit_curve <- function(t, m, n, r, model = "u", level = "u"){
if(level != "u" & level != "c"){
stop('Undefined specification for the level argument.' )
}
if(model == "u") {
df <- data.frame(x = m:n,
value = unit_curve(t = t, m = m, n = m:n, r = r),
cumulative.value = cumsum(unit_curve(t = t, m, n = m:n, r = r)))
if(level == "u") {
ggplot(data = df, aes(x = x, y = value)) +
geom_line()
} else {
ggplot(data = df, aes(x = x, y = cumulative.value)) +
geom_line()
}
} else if(model == "ca") {
df <- data.frame(x = m:n,
value = ca_unit(t = t, m = m, n = m:n, r = r),
cumulative.value = cumsum(ca_unit(t = t, m = m, n = m:n, r = r)))
if(level == "u") {
ggplot(data = df, aes(x = x, y = value)) +
geom_line()
} else {
ggplot(data = df, aes(x = x, y = cumulative.value)) +
geom_line()
}
} else if(model == "both") {
df1 <- data.frame(x = m:n,
model = "unit model",
value = unit_curve(t = t, m = m, n = m:n, r = r),
cumulative.value = cumsum(unit_curve(t = t, m, n = m:n, r = r)))
df2 <- data.frame(x = m:n,
model = "ca model",
value = ca_unit(t = t, m = m, n = m:n, r = r),
cumulative.value = cumsum(ca_unit(t = t, m = m, n = m:n, r = r)))
df <- rbind(df1, df2)
if(level == "u") {
ggplot(data = df, aes(x = x, y = value, color = model)) +
geom_line()
} else{
ggplot(data = df, aes(x = x, y = cumulative.value, color = model)) +
geom_line()
}
}
}
plot_unit_curve(t = 100, m = 1, n = 125, r = .85, model = "u", level = "u")
plot_unit_curve(t = 100, m = 1, n = 125, r = .85, model = "u", level = "c")
plot_unit_curve(t = 100, m = 1, n = 125, r = .85, model = "ca", level = "u")
plot_unit_curve(t = 100, m = 1, n = 125, r = .85, model = "ca", level = "c")
cum_error <- function(n, r1, r2){
if(!is.numeric(n) | !is.numeric(r1) | !is.numeric(r2)){
stop('This function only works for numeric inputs!\n',
'You have provided objects of the following classes:\n',
'n: ', class(n), '\n',
'r1: ', class(r1), '\n',
'r2: ', class(r2))
}
if(r1 == r2){
return('The learning curve rates you are comparing are the same.')
}
b1 <- log(r1)/log(2)
b2 <- log(r2)/log(2)
y <- n^(b2 - b1) - 1
return(y)
}
cum_error(n = 250, r1 = .85, r2 = .87)
unit_curve(t = 250, n = 125, r = .85)
unit_curve(t = 250, n = 125, r = .87)
agg_curve <- function(t, r, n, na.rm = FALSE){
if(!is.numeric(t) | !is.numeric(n) | !is.numeric(r)){
stop('This function only works for numeric inputs!\n',
'You have provided objects of the following classes:\n',
't: ', class(t), '\n',
'n: ', class(n), '\n',
'r: ', class(r))
}
if(na.rm == TRUE) {
t <- t[!is.na(t)]
n <- n[!is.na(n)]
r <- r[!is.na(r)]
warning('Any strings with NA were filtered. This may result in \n',
'unexpected recycling.')
}
H <- sum(t)
b <- log(r)/log(2)
c <- 1 + b
hours_i <- t * n^c
hours_all <- sum(hours_i)
B <- (log(hours_all) - log(H)) / log(n)
y <- H*n^B
return(y)
}
t <- c(70, 45, 25)
r <- c(.85, .87, .80)
agg_curve(t = t, r = r, n = 300)
natural_slope(r = c(.80, .85, .90))
natural_slope <- function(r, na.rm = FALSE){
if(!is.numeric(r)){
stop('This function only works for numeric inputs!\n',
'You have provided a rate in the form of a ',class(r))
}
if(na.rm == TRUE) {
r <- r[!is.na(r)]
}
b <- log(r)/log(2)
return(b)
}
natural_slope(r = c(.80, .85, .90))
lc_rate <- function(b, na.rm = FALSE){
if(!is.numeric(b)){
stop('This function only works for numeric inputs!\n',
'You have provided a natural slope in the form of a ',class(b))
}
if(na.rm == TRUE) {
b <- b[!is.na(b)]
}
y = 10^(b * log10(2) + 2)/100
return(y)
}
lc_rate(b = c(-.19, -.22, -.25))
blog_gen()
library(brocks)
help(package = "brocks")
blog_gen()
natural_slope_est <- function(T, t, n){
if(!is.numeric(T) | !is.numeric(t) | !is.numeric(n)){
stop('This function only works for numeric inputs!\n',
'You have provided objects of the following classes:\n',
'T: ', class(T), '\n',
't: ', class(t), '\n',
'n: ', class(n))
}
b <- (log(T) - log(t)) / log(n) - 1
return(b)
}
80*250
natural_slope_est(T = 17250, t = 80, n = 250)
lc_rate_est <- function(T, t, n){
if(!is.numeric(T) | !is.numeric(t) | !is.numeric(n)){
stop('This function only works for numeric inputs!\n',
'You have provided objects of the following classes:\n',
'T: ', class(T), '\n',
't: ', class(t), '\n',
'n: ', class(n))
}
b <- (log(T) - log(t)) / log(n) - 1
y = 10^(b * log10(2) + 2)/100
return(y)
}
lc_rate_est(T = 17250, t = 80, n = 250)
lc_rate_est(T = 14250, t = 80, n = 250)
lc_rate_est(T = 10250, t = 80, n = 250)
lc_rate_est(T = 8250, t = 80, n = 250)
lc_rate_est(T = 8250, t = 80, n = 250)
blog_gen()
library(brocks)
new_post(title = "84th MORS Symposium")
blog_gen()
library(brocks)
new_post(title = "Session 1&#58; Deworming Kenya - Translating Research to Action")
blog_gen()
library(brocks)
new_post(title = "Monthly Reading Recap")
library(brocks)
new_post(title = "Session Two: Our Piece of the Pie")
blog_gen()
blog_gen()
new_post(title = "Defining and Measuring Success in a Harm-reduction Context I")
blog_gen()
blog_gen()
blog_gen()
blog_gen()
15+37+69+131
blog_gen()
new_post(title = "Impact Evaluation I")
blog_gen()
blog_gen()
new_post(title = "Impact Evaluation II: Randomized Experiments")
blog_gen()
blog_gen()
new_post(title = "Process Evaluations")
blog_gen()
library(brocks)
1/36
blog_gen()
sample(1:10, 25)
?sample
sample(x = 1:10, size = 25)
sample(x = 1:100, size = 25)
sample(x = 1:100, size = 25)
set.seed(5)
sample(x = 1:100, size = 25)
set.seed(5)
sample(x = 1:100, size = 25)
rep(TRUE, 50)
c(rep(TRUE, 50), rep(FALSE, 50))
sample(c(rep(TRUE, 500), rep(FALSE, 500)), 100)
sum(sample(c(rep(TRUE, 500), rep(FALSE, 500)), 100))
sum(sample(c(rep(TRUE, 500), rep(FALSE, 500)), 200))
1:100
sample(1:100, 25)
c(rep(TRUE, 50), rep(FALSE, 50))
sum(sample(c(rep(TRUE, 50), rep(FALSE, 50)), 25))
sum(sample(c(rep(TRUE, 50), rep(FALSE, 50)), 50))
blog_gen()
blog_gen()
new_post(title = "Impact Evaluations III - Non-experimental Methods")
blog_gen()
new_post(title = "Designing an Impact Evaluation")
new_post(title = "Lean Decision-Making Impact Evaluations")
blog_gen()
library(brocks)
new_post(title = "Replication")
blog_gen()
new_post(title = "Impact Evaluation V")
blog_gen()
new_post(title = "Aggregating Evidence")
blog_gen()
blog_gen()
